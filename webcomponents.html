<html>
  <head>
    <title>Pratap Sahu</title>
    <style>
        body {
            font-size: 16px;
            font-family: Arial;
        }
        .container {
              max-width: 980px;
              margin: 0 auto;
              border: 1px solid #ccc;
              border-radius: 5px;
              padding: 20px;
          }
          pre {
              background: #eee;
              border-radius: 5px;
              padding: 5px;
              /* text-align: left; */
          }
    </style>
  </head>
  <body>
      <div class="container">
        <h1>Web Components</h1>
        <p>
          Web components is a suite of different technologies allowing you to create reusable custom elements with their functionality encapsulated away from the rest of your code - and reuse them in your web apps.
          It consists of three main technologies:-
          <ol>
              <li>
                  <strong>Custom elements</strong>: A set of JavaScript APIs that allow you to define custom elements and their behavior.
              </li>
              <li>
                  <strong>Shadow DOM</strong>: A set of JavaScript APIs for attaching an encapsulated "shadow" DOM tree to an element - which is rendered separately from the main document DOM - and controlling associated functionality.
                  In this way, you can keep an element's features private, so they can be scripted and styled without the fear of collision with other parts of the document.
              </li>
              <li>
                  <strong>HTML templates</strong>: The <code>&lt;template&gt;</code> and <code>&lt;slot&gt;</code> elements enable you to write markup templates that are not displayed in the rendered page.
                  These can be reused multiple times in the web component.
              </li>
          </ol>
        </p>
        <h2>Steps to create a web component</h2>
        <p>
          Below are the steps to create a web component:-
          <ol>
            <li>
              Create a class for the web component
            </li>
            <li>
              Register your new custom element using the CustomElementRegistry.define() method, passing it the element name to be defined, the class or function in which its functionality is specified. 
            </li>
            <li>
              If required, attach a shadow DOM to the custom element using Element.attachShadow() method. Add child elements, event listeners, etc., to the shadow DOM using regular DOM methods.
            </li>
            <li>
              If required, define an HTML template using <code>&lt;template&gt;</code> and <code>&lt;slot&gt;</code>. Again use regular DOM methods to clone the template and attach it to your shadow DOM.
            </li>
            <li>
              Use your custom element wherever you like on your page.
            </li>
          </ol>
        </p>
        <h2>Custom elements</h2>
        <p>
          There are two kinds of custom elements:
          <ol>
            <li>
              <strong>Autonomous custom elements</strong> - "all-new" elements, extending the abstract HTMLElement class.
            </li>
            <li>
              <strong>Customized built-in elements</strong> - extending built-in elements, like a customized button, based on HTMLButtonElement etc.
            </li>
          </ol>
          <strong>Example:-</strong>
          <pre>
            <code>
              class MyComponent extends HTMLElement {
                connectedCallback(){
                  let name = this.getAttribute('name');
                  this.innerHTML = `&lt;h1&gt;Hello ${name}&lt;/h1&gt;`;
                }
              }
              customElements.define('my-component', MyComponent);
              <my-component name="Pratap"></my-component>
            </code>
          </pre>
        </p>
        <h3>Custom element Life cycle</h3>
        <p>
          <pre>
            <code>
              class MyElement extends HTMLElement {
                constructor() {
                  super();
                  //element created
                }
                
                connectedCallback(){
                  // browser calls this method when the element is added to the document
                  // (can be called many times if an element is repeatedly added or removed)
                }
                
                disconnectedCallback() {
                  // browser calls this method when the element is removed from the document
                  // (can be called many times if an element is repeatedly added/removed)
                }
                
                static get observedAttributes() {
                  return [/* array of attribute names to monitor for changes */];
                }
                
                attributeChangedCallback(name, oldValue, newValue) {
                  // called when one of attributes listed above is modified
                }
                
                adoptedCallback() {
                  // called when the element is moved to a new document
                  // (happens in document.adoptNode, very rarely used)
                }
                
                // there can be other element methods and properties
              }
            </code>
          </pre>
        </p>
        <h3>Methods to get information about custom elements</h3>
        <p>
          <ol>
            <li>
              <strong>customElements.get(name)</strong> - returns the class for a custom element with the given name,
            </li>
            <li>
              <strong>customElements.whenDefined(name)</strong> - returns a promise that resolves (without value) when a custom element with the given name becomes defined.
            </li>
          </ol>
        </p>
        <h3>Observing attributes</h3>
        <p>
          We can observe attributes by providing their list in observedAttributes() static getter and attributeChangedCallback() is called when the attributes are modified.
          <pre>
          </pre>
            <code>
              class TimeFOrmatted extends HTMLElement {
                render() {
                  let date = new Date(this.getAttribute('datetime') || Date.now());
                  this.innerHTML = new Intl.DateTimeFormat("default", {
                                     year: this.getAttribute('year') || undefined,
                    
                                   })
                                   .format(date);
                }
              }
            </code>
        </p>
      </div>
    </body>
  </html>
