<html>
  <head>
    <title>Pratap Sahu</title>
    <style>
        body {
            font-size: 16px;
            font-family: Arial;
        }
        .container {
              max-width: 980px;
              margin: 0 auto;
              border: 1px solid #ccc;
              border-radius: 5px;
              padding: 20px;
          }
          pre {
              background: #eee;
              border-radius: 5px;
              padding: 5px;
              /* text-align: left; */
          }
    </style>
  </head>
  <body>
      <div class="container">
        <h1>Web Components</h1>
        <p>
          Web components is a suite of different technologies allowing you to create reusable custom elements with their functionality encapsulated away from the rest of your code - and reuse them in your web apps.
          It consists of three main technologies:-
          <ol>
              <li>
                  <strong>Custom elements</strong>: A set of JavaScript APIs that allow you to define custom elements and their behavior.
              </li>
              <li>
                  <strong>Shadow DOM</strong>: A set of JavaScript APIs for attaching an encapsulated "shadow" DOM tree to an element - which is rendered separately from the main document DOM - and controlling associated functionality.
                  In this way, you can keep an element's features private, so they can be scripted and styled without the fear of collision with other parts of the document.
              </li>
              <li>
                  <strong>HTML templates</strong>: The <code>&lt;template&gt;</code> and <code>&lt;slot&gt;</code> elements enable you to write markup templates that are not displayed in the rendered page.
                  These can be reused multiple times in the web component.
              </li>
          </ol>
        </p>
        <h2>Steps to create a web component</h2>
        <p>
          Below are the steps to create a web component:-
          <ol>
            <li>
              Create a class for the web component
            </li>
            <li>
              Register your new custom element using the CustomElementRegistry.define() method, passing it the element name to be defined, the class or function in which its functionality is specified. 
            </li>
            <li>
              If required, attach a shadow DOM to the custom element using Element.attachShadow() method. Add child elements, event listeners, etc., to the shadow DOM using regular DOM methods.
            </li>
            <li>
              If required, define an HTML template using <code>&lt;template&gt;</code> and <code>&lt;slot&gt;</code>. Again use regular DOM methods to clone the template and attach it to your shadow DOM.
            </li>
            <li>
              Use your custom element wherever you like on your page.
            </li>
          </ol>
        </p>
        <h2>Custom elements</h2>
        <p>
          There are two kinds of custom elements:
          <ol>
            <li>
              <strong>Autonomous custom elements</strong> - "all-new" elements, extending the abstract HTMLElement class.
            </li>
            <li>
              <strong>Customized built-in elements</strong> - extending built-in elements, like a customized button, based on HTMLButtonElement etc.
            </li>
          </ol>
          <strong>Example:-</strong>
          <pre>
            <code>
              class MyComponent extends HTMLElement {
                connectedCallback(){
                  let name = this.getAttribute('name');
                  this.innerHTML = `&lt;h1&gt;Hello ${name}&lt;/h1&gt;`;
                }
              }
              customElements.define('my-component', MyComponent);
              &lt;my-component name="Pratap"&gt;&lt;/my-component&gt;
            </code>
          </pre>
        </p>
        <h3>Custom element Life cycle</h3>
        <p>
          <pre>
            <code>
              class MyElement extends HTMLElement {
                constructor() {
                  super();
                  //element created
                }
                
                connectedCallback(){
                  // browser calls this method when the element is added to the document
                  // (can be called many times if an element is repeatedly added or removed)
                }
                
                disconnectedCallback() {
                  // browser calls this method when the element is removed from the document
                  // (can be called many times if an element is repeatedly added/removed)
                }
                
                static get observedAttributes() {
                  return [/* array of attribute names to monitor for changes */];
                }
                
                attributeChangedCallback(name, oldValue, newValue) {
                  // called when one of attributes listed above is modified
                }
                
                adoptedCallback() {
                  // called when the element is moved to a new document
                  // (happens in document.adoptNode, very rarely used)
                }
                
                // there can be other element methods and properties
              }
            </code>
          </pre>
        </p>
        <h3>Methods to get information about custom elements</h3>
        <p>
          <ol>
            <li>
              <strong>customElements.get(name)</strong> - returns the class for a custom element with the given name,
            </li>
            <li>
              <strong>customElements.whenDefined(name)</strong> - returns a promise that resolves (without value) when a custom element with the given name becomes defined.
            </li>
          </ol>
        </p>
        <h3>Observing attributes</h3>
        <p>
          We can observe attributes by providing their list in observedAttributes() static getter and attributeChangedCallback() is called when the attributes are modified.
          <pre>
            <code>
              class TimeFormatted extends HTMLElement {
                render() {
                  let date = new Date(this.getAttribute('datetime') || Date.now());
                  this.innerHTML = new Intl.DateTimeFormat("default", {
                                     year: this.getAttribute('year') || undefined,
                    
                                   })
                                   .format(date);
                }
              }
            </code>
        </pre>
       </p>
       <h3>Rendering Order</h3>
       <p>
          When HTML parser builds the DOM, elements are processed one after another, parents before children. E.g. if we have &lt;outer&gt;&lt;inner&gt;&lt;/inner&gt;&lt;/outer&gt;, then &lt;outer&gt; element is created and connected to DOM first, and then &lt;inner&gt;.
          For example, if a custom element tries to access innerHTML in connectedCallback, it gets nothing:
          <pre>
            <code>
              customElements.define('user-info', class extends HTMLElement {
                connectedCallback() {
                  alert(`${this.id} connected.`);
                  setTimeout(() => alert(`${this.id} initialized.`));
                }
              });

              &lt;user-info id="outer"&gt;
                &lt;user-info id="inner"&gt;&lt;/user-info&gt;
              &lt;/user-info&gt;
            </code>
        </pre>
       </p>
        <h2>Shadow DOM</h2>
        <p>
          Shadow DOM serves for encapsulation.<br/>
          It allows a component to have its very own "shadow" DOM tree, that can't be accidentally accessed from the main document.<br/>
          It allows a component to have local style rules and more.
          <h3>Shadow tree</h3>
          A DOM element can have two types of DOM subtrees:
          <ol>
            <li>
              Light tree – a regular DOM subtree, made of HTML children.
            </li>
            <li>
              Shadow tree – a hidden DOM subtree, not reflected in HTML, hidden from prying eyes.
            </li>
          </ol>
          There are two limitations of Shadow tree:
          <ol>
            <li>
              We can create only one shadow root per element.
            </li>
            <li>
              The elem must be either a custom element, or one of: “article”, “aside”, “blockquote”, “body”, “div”, “footer”, “h1…h6”, “header”, “main” “nav”, “p”, “section”, or “span”. Other elements, like <img>, can’t host shadow tree.
            </li>
          </ol>
          The mode option sets the encapsulation level. It must have any of two values:
          <ol>
            <li>
              "open" – the shadow root is available as elem.shadowRoot.
              Any code is able to access the shadow tree of elem.
            </li>
            <li>
              "closed" – elem.shadowRoot is always null.
              We can only access the shadow DOM by the reference returned by attachShadow (and probably hidden inside a class).
            </li>
          </ol>
          <pre>
            <code>
              customElements.define('show-hello', class extends HTMLElement {
                connectedCallback() {
                  const shadow = this.attachShadow({mode: 'open'});
                  shadow.innerHTML = `&lt;p&gt;
                    Hello, ${this.getAttribute('name')}
                  &lt;/p&gt;`;
                }
              });
            </code>
          </pre>
          <h3>Encapsulation</h3>
          Shadow DOM is isolated from the main document.
          <ol>
            <li>
              Shadow DOM elements are not visible to querySelector from the light DOM.
            </li>
            <li>
              Shadow DOM has own stylesheets. Style rules from the outer DOM don’t get applied.
            </li>
          </ol>
          <pre>
            <code>
              elem.attachShadow({mode: 'open'});
                // shadow tree has its own style (2)
              elem.shadowRoot.innerHTML = `
                &lt;style&gt; p { font-weight: bold; } &lt;/style&gt;
                &lt;p&gt;Hello, John!&lt;/p&gt;
              `;

              // &lt;p&gt; is only visible from queries inside the shadow tree (3)
              alert(document.querySelectorAll('p').length); // 0
              alert(elem.shadowRoot.querySelectorAll('p').length); // 1
            </code>
          </pre>
        </p>
        <h2>HTML templates</h2>
        <p>
          A built-in &lt;template&gt; element serves as a storage for HTML markup templates.<br/>
          The browser ignores it contents, only checks for syntax validity, but we can access and use it in JavaScript, to create other elements.<br/>
          We can put styles and scripts into &lt;template&gt; as well:
          <pre>
            <code>
              &lt;template id="tmpl"&gt;
                &lt;style&gt; p { font-weight: bold; } &lt;/style&gt;
                &lt;p id="message">&lt;/p&gt;
              &lt;/template&gt;

              &lt;div id="elem"&gt;Click me&lt;/div&gt;

              &lt;script&gt;
                elem.onclick = function() {
                  elem.attachShadow({mode: 'open'});

                  elem.shadowRoot.append(tmpl.content.cloneNode(true)); // (*)

                  elem.shadowRoot.getElementById('message').innerHTML = "Hello from the shadows!";
                };
              &lt;/script&gt;
            </code>
          </pre>
        </p>
        <h2>Shadow DOM slots, composition</h2>
        <p>
          Our custom elements may expect the actual content to be passed. And a &lt;custom-menu&gt; may expect menu items.
          The code that makes use of &lt;custom-menu&gt; can look like this:
          <pre>
            <code>
              &lt;custom-menu&gt;
                &lt;title&gt;Candy menu&lt;/title&gt;
                &lt;item&gt;Lollipop&lt;/item&gt;
                &lt;item&gt;Fruit Toast&lt;/item&gt;
                &lt;item&gt;Cup Cake&lt;/item&gt;
              &lt;custom-menu&gt;
            </code>
          </pre>
        </p>
      </div>
    </body>
  </html>
